#!/bin/bash
# -----------------------------------------------------------------------------
# Docker Stack Setup Script
# -----------------------------------------------------------------------------
# This script sets up a Docker stack with common development services
# It creates docker-compose files for services like PostgreSQL, MySQL, Redis, etc.
# -----------------------------------------------------------------------------

set -euo pipefail

# Color codes for output formatting
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly NC='\033[0m' # No Color

# Logging functions
log_info() { echo -e "${GREEN}[DOCKER-STACK]${NC} $*"; }
log_warn() { echo -e "${YELLOW}[DOCKER-STACK]${NC} $*"; }
log_error() { echo -e "${RED}[DOCKER-STACK]${NC} $*"; }

# Configuration
readonly STACK_DIR="/workspace/docker-stack"
readonly COMPOSE_DIR="$STACK_DIR/compose"

# Create Docker stack directory structure
setup_directory_structure() {
    log_info "Setting up Docker stack directory structure..."
    
    mkdir -p "$STACK_DIR"/{compose,data,logs,scripts}
    mkdir -p "$STACK_DIR/data"/{postgres,mysql,redis,mongo,elasticsearch}
    mkdir -p "$STACK_DIR/logs"/{postgres,mysql,redis,mongo,elasticsearch,nginx}
    
    log_info "Directory structure created at: $STACK_DIR"
}

# Create PostgreSQL docker-compose file
create_postgres_compose() {
    local compose_file="$COMPOSE_DIR/postgres.yml"
    
    cat > "$compose_file" << 'EOF'
version: '3.8'

services:
  postgres:
    image: postgres:16-alpine
    container_name: dev-postgres
    restart: unless-stopped
    environment:
      POSTGRES_DB: ${POSTGRES_DB:-devdb}
      POSTGRES_USER: ${POSTGRES_USER:-postgres}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-postgres}
      PGDATA: /var/lib/postgresql/data/pgdata
    ports:
      - "${POSTGRES_PORT:-5432}:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init-scripts:/docker-entrypoint-initdb.d:ro
    networks:
      - dev-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-postgres} -d ${POSTGRES_DB:-devdb}"]
      interval: 30s
      timeout: 10s
      retries: 3

  pgadmin:
    image: dpage/pgadmin4:latest
    container_name: dev-pgadmin
    restart: unless-stopped
    environment:
      PGADMIN_DEFAULT_EMAIL: ${PGADMIN_EMAIL:-admin@example.com}
      PGADMIN_DEFAULT_PASSWORD: ${PGADMIN_PASSWORD:-admin}
      PGADMIN_CONFIG_SERVER_MODE: 'False'
    ports:
      - "${PGADMIN_PORT:-8080}:80"
    volumes:
      - pgadmin_data:/var/lib/pgadmin
    networks:
      - dev-network
    depends_on:
      - postgres

volumes:
  postgres_data:
  pgadmin_data:

networks:
  dev-network:
    driver: bridge
EOF

    log_info "Created PostgreSQL compose file: $compose_file"
}

# Create MySQL docker-compose file
create_mysql_compose() {
    local compose_file="$COMPOSE_DIR/mysql.yml"
    
    cat > "$compose_file" << 'EOF'
version: '3.8'

services:
  mysql:
    image: mysql:8.0
    container_name: dev-mysql
    restart: unless-stopped
    environment:
      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD:-root}
      MYSQL_DATABASE: ${MYSQL_DATABASE:-devdb}
      MYSQL_USER: ${MYSQL_USER:-user}
      MYSQL_PASSWORD: ${MYSQL_PASSWORD:-password}
    ports:
      - "${MYSQL_PORT:-3306}:3306"
    volumes:
      - mysql_data:/var/lib/mysql
      - ./mysql-config:/etc/mysql/conf.d:ro
      - ./init-scripts:/docker-entrypoint-initdb.d:ro
    networks:
      - dev-network
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost"]
      interval: 30s
      timeout: 10s
      retries: 3

  phpmyadmin:
    image: phpmyadmin/phpmyadmin:latest
    container_name: dev-phpmyadmin
    restart: unless-stopped
    environment:
      PMA_HOST: mysql
      PMA_PORT: 3306
      PMA_USER: ${MYSQL_USER:-user}
      PMA_PASSWORD: ${MYSQL_PASSWORD:-password}
    ports:
      - "${PHPMYADMIN_PORT:-8081}:80"
    networks:
      - dev-network
    depends_on:
      - mysql

volumes:
  mysql_data:

networks:
  dev-network:
    driver: bridge
EOF

    log_info "Created MySQL compose file: $compose_file"
}

# Create Redis docker-compose file
create_redis_compose() {
    local compose_file="$COMPOSE_DIR/redis.yml"
    
    cat > "$compose_file" << 'EOF'
version: '3.8'

services:
  redis:
    image: redis:7-alpine
    container_name: dev-redis
    restart: unless-stopped
    command: redis-server --appendonly yes --requirepass ${REDIS_PASSWORD:-redis}
    ports:
      - "${REDIS_PORT:-6379}:6379"
    volumes:
      - redis_data:/data
    networks:
      - dev-network
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 30s
      timeout: 10s
      retries: 3

  redis-commander:
    image: rediscommander/redis-commander:latest
    container_name: dev-redis-commander
    restart: unless-stopped
    environment:
      REDIS_HOSTS: local:redis:6379:0:${REDIS_PASSWORD:-redis}
    ports:
      - "${REDIS_COMMANDER_PORT:-8082}:8081"
    networks:
      - dev-network
    depends_on:
      - redis

volumes:
  redis_data:

networks:
  dev-network:
    driver: bridge
EOF

    log_info "Created Redis compose file: $compose_file"
}

# Create MongoDB docker-compose file
create_mongo_compose() {
    local compose_file="$COMPOSE_DIR/mongo.yml"
    
    cat > "$compose_file" << 'EOF'
version: '3.8'

services:
  mongo:
    image: mongo:7
    container_name: dev-mongo
    restart: unless-stopped
    environment:
      MONGO_INITDB_ROOT_USERNAME: ${MONGO_ROOT_USERNAME:-admin}
      MONGO_INITDB_ROOT_PASSWORD: ${MONGO_ROOT_PASSWORD:-admin}
      MONGO_INITDB_DATABASE: ${MONGO_DATABASE:-devdb}
    ports:
      - "${MONGO_PORT:-27017}:27017"
    volumes:
      - mongo_data:/data/db
      - ./mongo-init:/docker-entrypoint-initdb.d:ro
    networks:
      - dev-network
    healthcheck:
      test: ["CMD", "mongosh", "--eval", "db.adminCommand('ping')"]
      interval: 30s
      timeout: 10s
      retries: 3

  mongo-express:
    image: mongo-express:latest
    container_name: dev-mongo-express
    restart: unless-stopped
    environment:
      ME_CONFIG_MONGODB_ADMINUSERNAME: ${MONGO_ROOT_USERNAME:-admin}
      ME_CONFIG_MONGODB_ADMINPASSWORD: ${MONGO_ROOT_PASSWORD:-admin}
      ME_CONFIG_MONGODB_SERVER: mongo
      ME_CONFIG_BASICAUTH_USERNAME: ${MONGO_EXPRESS_USER:-admin}
      ME_CONFIG_BASICAUTH_PASSWORD: ${MONGO_EXPRESS_PASSWORD:-admin}
    ports:
      - "${MONGO_EXPRESS_PORT:-8083}:8081"
    networks:
      - dev-network
    depends_on:
      - mongo

volumes:
  mongo_data:

networks:
  dev-network:
    driver: bridge
EOF

    log_info "Created MongoDB compose file: $compose_file"
}

# Create environment template
create_env_template() {
    local env_file="$STACK_DIR/.env.template"
    
    cat > "$env_file" << 'EOF'
# =============================================================================
# Docker Stack Environment Configuration Template
# =============================================================================
# Copy this file to .env and customize the values for your environment

# =============================================================================
# PostgreSQL Configuration
# =============================================================================
POSTGRES_DB=devdb
POSTGRES_USER=postgres
POSTGRES_PASSWORD=postgres
POSTGRES_PORT=5432

# pgAdmin Configuration
PGADMIN_EMAIL=admin@example.com
PGADMIN_PASSWORD=admin
PGADMIN_PORT=8080

# =============================================================================
# MySQL Configuration
# =============================================================================
MYSQL_ROOT_PASSWORD=root
MYSQL_DATABASE=devdb
MYSQL_USER=user
MYSQL_PASSWORD=password
MYSQL_PORT=3306

# phpMyAdmin Configuration
PHPMYADMIN_PORT=8081

# =============================================================================
# Redis Configuration
# =============================================================================
REDIS_PASSWORD=redis
REDIS_PORT=6379
REDIS_COMMANDER_PORT=8082

# =============================================================================
# MongoDB Configuration
# =============================================================================
MONGO_ROOT_USERNAME=admin
MONGO_ROOT_PASSWORD=admin
MONGO_DATABASE=devdb
MONGO_PORT=27017

# Mongo Express Configuration
MONGO_EXPRESS_USER=admin
MONGO_EXPRESS_PASSWORD=admin
MONGO_EXPRESS_PORT=8083

# =============================================================================
# Elasticsearch Configuration
# =============================================================================
ELASTIC_PASSWORD=elastic
ELASTICSEARCH_PORT=9200
KIBANA_PORT=5601
EOF

    log_info "Created environment template: $env_file"
}

# Create stack management script
create_stack_script() {
    local script_file="$STACK_DIR/stack.sh"
    
    cat > "$script_file" << 'EOF'
#!/bin/bash
# Docker Stack Management Script

set -euo pipefail

readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly COMPOSE_DIR="$SCRIPT_DIR/compose"

# Load environment variables
if [[ -f "$SCRIPT_DIR/.env" ]]; then
    set -a
    source "$SCRIPT_DIR/.env"
    set +a
fi

show_usage() {
    cat << EOF
Docker Stack Management

Usage: $0 <command> [service]

Commands:
  up [service]      Start service(s)
  down [service]    Stop service(s)
  restart [service] Restart service(s)
  logs [service]    Show logs for service(s)
  ps               Show running services
  list             List available services

Available services:
  postgres, mysql, redis, mongo, all

Examples:
  $0 up postgres    # Start PostgreSQL
  $0 up all         # Start all services
  $0 down mysql     # Stop MySQL
  $0 logs redis     # Show Redis logs

EOF
}

run_compose_command() {
    local cmd="$1"
    local service="$2"
    
    case "$service" in
        "postgres")
            docker-compose -f "$COMPOSE_DIR/postgres.yml" "$cmd"
            ;;
        "mysql")
            docker-compose -f "$COMPOSE_DIR/mysql.yml" "$cmd"
            ;;
        "redis")
            docker-compose -f "$COMPOSE_DIR/redis.yml" "$cmd"
            ;;
        "mongo")
            docker-compose -f "$COMPOSE_DIR/mongo.yml" "$cmd"
            ;;
        "all")
            for svc in postgres mysql redis mongo; do
                echo "==> Running $cmd for $svc"
                docker-compose -f "$COMPOSE_DIR/$svc.yml" "$cmd" || true
            done
            ;;
        *)
            echo "Error: Unknown service '$service'"
            show_usage
            exit 1
            ;;
    esac
}

main() {
    case "${1:-}" in
        "up")
            run_compose_command "up -d" "${2:-all}"
            ;;
        "down")
            run_compose_command "down" "${2:-all}"
            ;;
        "restart")
            run_compose_command "restart" "${2:-all}"
            ;;
        "logs")
            run_compose_command "logs -f" "${2:-all}"
            ;;
        "ps")
            docker ps --filter "name=dev-"
            ;;
        "list")
            echo "Available services: postgres, mysql, redis, mongo"
            ;;
        *)
            show_usage
            ;;
    esac
}

main "$@"
EOF

    chmod +x "$script_file"
    log_info "Created stack management script: $script_file"
}

# Create README
create_readme() {
    local readme_file="$STACK_DIR/README.md"
    
    cat > "$readme_file" << 'EOF'
# Docker Development Stack

This directory contains Docker Compose configurations for common development services.

## Quick Start

1. Copy the environment template:
   ```bash
   cp .env.template .env
   ```

2. Edit `.env` with your preferred settings

3. Start services using the stack script:
   ```bash
   ./stack.sh up postgres    # Start PostgreSQL only
   ./stack.sh up all         # Start all services
   ```

## Available Services

### PostgreSQL
- **Database**: Port 5432
- **pgAdmin**: Port 8080 (default)
- **Access**: http://localhost:8080

### MySQL
- **Database**: Port 3306
- **phpMyAdmin**: Port 8081 (default)
- **Access**: http://localhost:8081

### Redis
- **Database**: Port 6379
- **Redis Commander**: Port 8082 (default)
- **Access**: http://localhost:8082

### MongoDB
- **Database**: Port 27017
- **Mongo Express**: Port 8083 (default)
- **Access**: http://localhost:8083

## Management Commands

```bash
# Start services
./stack.sh up [service]

# Stop services
./stack.sh down [service]

# View logs
./stack.sh logs [service]

# Show running containers
./stack.sh ps

# List available services
./stack.sh list
```

## Data Persistence

All data is persisted in Docker volumes. To completely remove data:

```bash
./stack.sh down [service]
docker volume rm $(docker volume ls -q | grep "dev-")
```

## Configuration

Each service can be configured via environment variables in the `.env` file.
See `.env.template` for all available options.
EOF

    log_info "Created README: $readme_file"
}

main() {
    log_info "Setting up Docker development stack..."
    
    setup_directory_structure
    
    # Create compose files for each service
    create_postgres_compose
    create_mysql_compose
    create_redis_compose
    create_mongo_compose
    
    # Create supporting files
    create_env_template
    create_stack_script
    create_readme
    
    log_info "Docker stack setup completed at: $STACK_DIR"
    log_info "To get started:"
    log_info "  1. cd $STACK_DIR"
    log_info "  2. cp .env.template .env"
    log_info "  3. ./stack.sh up [service]"
}

# Only run if called directly (not sourced)
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
