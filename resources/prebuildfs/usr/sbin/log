#!/bin/bash
# LaraGIS Enhanced Logging CLI Tool v4.0.0
# High-performance, modular logging system with auto-dependency management
# Supports: Ubuntu, Oracle Linux, Debian, RHEL, CentOS, Alpine
# Dependencies: gum, getoptions (auto-installed if missing)
# Author: LaraGIS Team
# License: MIT

set -euo pipefail

#################################################################
# METADATA AND VERSION INFO
#################################################################

readonly SCRIPT_NAME="log"
readonly SCRIPT_VERSION="4.0.0"
readonly SCRIPT_BUILD="$(date +%Y%m%d-%H%M%S)"
readonly SCRIPT_DESCRIPTION="LaraGIS Enhanced Logging CLI Tool"
readonly SCRIPT_AUTHOR="LaraGIS Team"
readonly SCRIPT_LICENSE="MIT"

#################################################################
# GLOBAL CONSTANTS AND CONFIGURATION
#################################################################

# Cache frequently used values for performance
declare -g _log_module=""
declare -g _log_quiet_mode=""
declare -g _log_debug_mode=""
declare -g _log_has_gum=""
declare -g _log_has_getoptions=""
declare -g _log_initialized=false

# Color constants (readonly for performance)
readonly -A LOG_COLORS=(
  ["RED"]='\033[0;31m'
  ["GREEN"]='\033[0;32m'
  ["YELLOW"]='\033[1;33m'
  ["BLUE"]='\033[0;34m'
  ["PURPLE"]='\033[0;35m'
  ["CYAN"]='\033[0;36m'
  ["GRAY"]='\033[0;90m'
  ["WHITE"]='\033[0;97m'
  ["BOLD"]='\033[1m'
  ["RESET"]='\033[0m'
)

# Gum color palette (optimized for readability)
readonly -A GUM_COLORS=(
  ["INFO"]="#00d7ff"
  ["WARN"]="#ffa500"
  ["ERROR"]="#ff0000"
  ["SUCCESS"]="#00ff00"
  ["STEP"]="#ff69b4"
  ["DEBUG"]="#808080"
  ["TIME"]="#666666"
  ["MODULE"]="#00c9d3"
  ["MESSAGE"]="#ffffff"
)

# Log level priorities (for filtering)
readonly -A LOG_LEVEL_PRIORITIES=(
  ["DEBUG"]=10
  ["INFO"]=20
  ["WARN"]=30
  ["ERROR"]=40
  ["SUCCESS"]=20
  ["STEP"]=20
)

# Default configuration values
readonly -A LOG_DEFAULTS=(
  ["level"]="INFO"
  ["file"]=""
  ["format"]="gum"
  ["theme"]="pink"
  ["time_format"]="%Y-%m-%d %H:%M:%S"
  ["rotation"]="true"
  ["max_size"]="10M"
  ["max_files"]="5"
  ["colors"]="true"
  ["quiet"]="false"
  ["debug"]="false"
  ["module"]="SYSTEM"
)

#################################################################
# SYSTEM DETECTION AND PACKAGE MANAGEMENT
#################################################################

# Detect operating system
detect_os() {
  if [[ -f /etc/os-release ]]; then
    source /etc/os-release
    echo "${ID:-unknown}"
  elif [[ -f /etc/redhat-release ]]; then
    echo "rhel"
  elif [[ -f /etc/debian_version ]]; then
    echo "debian"
  elif [[ "$(uname)" == "Darwin" ]]; then
    echo "macos"
  else
    echo "unknown"
  fi
}

# Get package manager based on OS
get_package_manager() {
  local os_id
  os_id=$(detect_os)
  
  case "$os_id" in
    ubuntu|debian)
      echo "apt"
      ;;
    ol|rhel|centos|rocky|almalinux)
      echo "dnf"
      ;;
    fedora)
      echo "dnf"
      ;;
    alpine)
      echo "apk"
      ;;
    arch)
      echo "pacman"
      ;;
    *)
      echo "unknown"
      ;;
  esac
}

# Install package using appropriate package manager
install_package() {
  local package="$1"
  local pm
  pm=$(get_package_manager)
  
  echo "Installing $package using $pm package manager..."
  
  case "$pm" in
    apt)
      sudo apt update && sudo apt install -y "$package"
      ;;
    dnf)
      sudo dnf install -y "$package"
      ;;
    apk)
      sudo apk add "$package"
      ;;
    pacman)
      sudo pacman -S --noconfirm "$package"
      ;;
    *)
      echo "Warning: Unknown package manager. Please install $package manually."
      return 1
      ;;
  esac
}

# Check if running as root or if sudo is available
check_sudo_requirement() {
  # If running as root, no need for sudo
  if [[ $EUID -eq 0 ]]; then
    echo "‚úÖ Running as root - no sudo required"
    return 0
  fi
  
  # If not root, check if sudo is available
  if command -v sudo >/dev/null 2>&1; then
    echo "‚úÖ sudo is available for package installation"
    return 0
  else
    echo "‚ùå Not running as root and sudo not available"
    echo "Please either:"
    echo "  1. Run as root: log install-deps"
    echo "  2. Install sudo first, then: sudo log install-deps"
    return 1
  fi
}

# Fallback gum installation using binary
_install_gum_fallback() {
  echo "Using fallback binary installation method..."
  local target_version="${GUM_VERSION:-latest}"
  local version_to_use
  
  # Determine if we need sudo prefix for commands
  local sudo_cmd=""
  if [[ $EUID -ne 0 ]]; then
    sudo_cmd="sudo "
  fi
  
  if [[ "$target_version" == "latest" ]]; then
    echo "Getting latest version from GitHub API..."
    version_to_use=$(curl -s https://api.github.com/repos/charmbracelet/gum/releases/latest | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')
    if [[ -z "$version_to_use" ]]; then
      echo "‚ùå Failed to get latest version from GitHub API"
      return 1
    fi
  else
    version_to_use="$target_version"
    # Ensure version starts with 'v'
    [[ "$version_to_use" != v* ]] && version_to_use="v${version_to_use}"
  fi
  
  echo "Installing gum version: $version_to_use"
  
  local arch
  arch=$(uname -m)
  
  # Try different binary URL formats
  local urls=(
    "https://github.com/charmbracelet/gum/releases/download/${version_to_use}/gum_${version_to_use#v}_Linux_${arch}.tar.gz"
    "https://github.com/charmbracelet/gum/releases/download/${version_to_use}/gum_${version_to_use#v}_linux_${arch}.tar.gz"
  )
  
  for url in "${urls[@]}"; do
    echo "Trying URL: $url"
    local temp_dir="/tmp/gum-fallback-$$"
    
    if mkdir -p "$temp_dir" && cd "$temp_dir"; then
      if curl -sL "$url" | tar xz 2>/dev/null; then
        if [[ -f "gum" ]]; then
          echo "Installing gum to /usr/local/bin/"
          if ${sudo_cmd}mv gum /usr/local/bin/ && ${sudo_cmd}chmod +x /usr/local/bin/gum; then
            cd - >/dev/null
            echo "üóëÔ∏è Cleaning up temporary files..."
            rm -rf "$temp_dir"
            echo "‚úÖ Gum $version_to_use installed successfully via fallback method"
            return 0
          fi
        fi
      fi
      cd - >/dev/null
      echo "üóëÔ∏è Cleaning up failed download..."
      rm -rf "$temp_dir"
    fi
  done
  
  echo "‚ùå All installation methods failed"
  return 1
}

# Check and install gum if needed
ensure_gum_installed() {
  if command -v gum >/dev/null 2>&1; then
    local current_version
    current_version=$(gum --version 2>/dev/null | grep -o 'v[0-9.]*[0-9]' | head -1 || echo "unknown")
    echo "‚úÖ Gum is already installed (version: $current_version)"
    _log_has_gum=true
    return 0
  fi
  
  echo "Gum not found. Installing..."
  
  # Check sudo requirement instead of installing sudo
  if ! check_sudo_requirement; then
    echo "‚ùå Cannot install gum without proper permissions"
    _log_has_gum=false
    return 1
  fi
  
  # Determine if we need sudo prefix for commands
  local sudo_cmd=""
  if [[ $EUID -ne 0 ]]; then
    sudo_cmd="sudo "
  fi
  
  # Try package manager first
  local pm
  pm=$(get_package_manager)
  
  case "$pm" in
    apt)
      # For Ubuntu/Debian, try version-specific installation first
      local target_version="${GUM_VERSION:-latest}"
      echo "Attempting installation for Ubuntu/Debian..."
      echo "Target version: $target_version"
      
      if [[ "$target_version" != "latest" ]]; then
        # Try to install specific version from GitHub releases
        echo "Installing specific version $target_version..."
        local version_to_use="$target_version"
        [[ "$version_to_use" != v* ]] && version_to_use="v${version_to_use}"
        
        local arch
        arch=$(uname -m)
        [[ "$arch" == "x86_64" ]] && arch="amd64"
        
        local deb_url="https://github.com/charmbracelet/gum/releases/download/${version_to_use}/gum_${version_to_use#v}_${arch}.deb"
        local deb_file="/tmp/gum_${version_to_use#v}_${arch}.deb"
        
        echo "Downloading DEB from: $deb_url"
        if curl -sL "$deb_url" -o "$deb_file"; then
          if [[ -f "$deb_file" ]] && [[ -s "$deb_file" ]]; then
            echo "Installing DEB package..."
            if ${sudo_cmd}dpkg -i "$deb_file" 2>/dev/null || ${sudo_cmd}apt-get install -f -y; then
              echo "üóëÔ∏è Cleaning up DEB file..."
              rm -f "$deb_file"
              echo "‚úÖ Gum $version_to_use installed successfully via DEB"
              return 0
            else
              echo "DEB installation failed, trying fallback..."
              echo "üóëÔ∏è Cleaning up failed DEB file..."
              rm -f "$deb_file"
              _install_gum_fallback
              return $?
            fi
          else
            echo "Downloaded DEB file is empty or missing, trying repository method..."
            echo "üóëÔ∏è Cleaning up empty DEB file..."
            rm -f "$deb_file"
          fi
        else
          echo "Failed to download DEB, trying repository method..."
        fi
      fi
      
      # Try charm's repository for latest version
      if ! command -v gum >/dev/null 2>&1; then
        echo "Adding charm repository and installing latest version..."
        local sources_file="/etc/apt/sources.list.d/charm.list"
        echo "deb [trusted=yes] https://repo.charm.sh/apt/ /" | ${sudo_cmd}tee "$sources_file" >/dev/null
        if ${sudo_cmd}apt update && ${sudo_cmd}apt install -y gum; then
          echo "‚úÖ Gum installed successfully from charm repository"
          return 0
        else
          echo "Repository installation failed, trying fallback..."
          # Clean up sources file if installation failed
          ${sudo_cmd}rm -f "$sources_file" 2>/dev/null
          _install_gum_fallback
          return $?
        fi
      fi
      ;;
    dnf)
      # For RHEL/Oracle Linux, try to use binary installation first (more reliable)
      echo "Attempting installation for Oracle Linux/RHEL..."
      local target_version="${GUM_VERSION:-latest}"
      local version_to_use
      
      if [[ "$target_version" == "latest" ]]; then
        echo "Getting latest version from GitHub API..."
        version_to_use=$(curl -s https://api.github.com/repos/charmbracelet/gum/releases/latest | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')
        if [[ -z "$version_to_use" ]]; then
          echo "Failed to get latest version, trying fallback installation..."
          _install_gum_fallback
          return $?
        fi
      else
        version_to_use="$target_version"
        # Ensure version starts with 'v'
        [[ "$version_to_use" != v* ]] && version_to_use="v${version_to_use}"
      fi
      
      echo "Installing gum version: $version_to_use"
      
      local arch
      arch=$(uname -m)
      
      # Try RPM installation with correct filename format
      echo "Trying RPM installation..."
      local rpm_url="https://github.com/charmbracelet/gum/releases/download/${version_to_use}/gum-${version_to_use#v}-1.${arch}.rpm"
      local rpm_file="/tmp/gum-${version_to_use#v}-1.${arch}.rpm"
      
      echo "Downloading RPM from: $rpm_url"
      if curl -sL "$rpm_url" -o "$rpm_file"; then
        if [[ -f "$rpm_file" ]] && [[ -s "$rpm_file" ]]; then
          echo "Installing RPM package..."
          if ${sudo_cmd}dnf install -y "$rpm_file"; then
            echo "üóëÔ∏è  Cleaning up RPM file..."
            rm -f "$rpm_file"
            echo "‚úÖ Gum $version_to_use installed successfully via RPM"
            return 0
          else
            echo "RPM installation failed, trying binary installation..."
            echo "üóëÔ∏è Cleaning up failed RPM file..."
            rm -f "$rpm_file"
          fi
        else
          echo "Downloaded RPM file is empty or missing"
          echo "üóëÔ∏è Cleaning up empty RPM file..."
          rm -f "$rpm_file"
        fi
      else
        echo "Failed to download RPM"
      fi
      
      # Fallback to binary installation
      echo "Trying binary installation..."
      local tar_url="https://github.com/charmbracelet/gum/releases/download/${version_to_use}/gum_${version_to_use#v}_Linux_x86_64.tar.gz"
      local temp_dir="/tmp/gum-install-$$"
      
      if mkdir -p "$temp_dir" && cd "$temp_dir"; then
        echo "Downloading binary from: $tar_url"
        if curl -sL "$tar_url" | tar xz; then
          if [[ -f "gum" ]]; then
            ${sudo_cmd}mv gum /usr/local/bin/
            ${sudo_cmd}chmod +x /usr/local/bin/gum
            cd - >/dev/null
            echo "üóëÔ∏è Cleaning up temporary files..."
            rm -rf "$temp_dir"
            echo "‚úÖ Gum $version_to_use installed successfully via binary"
            return 0
          fi
        fi
        cd - >/dev/null
        echo "üóëÔ∏è Cleaning up failed download..."
        rm -rf "$temp_dir"
      fi
      
      # Final fallback
      echo "Standard methods failed, trying fallback..."
      _install_gum_fallback
      return $?
      ;;
    *)
      # Fallback: install from GitHub releases (binary)
      _install_gum_fallback
      ;;
  esac
  
  # Verify installation
  if command -v gum >/dev/null 2>&1; then
    _log_has_gum=true
    echo "‚úÖ Gum installed successfully"
  else
    _log_has_gum=false
    echo "‚ö†Ô∏è Gum installation failed, falling back to plain text mode"
  fi
}

# Check and install getoptions if needed  
ensure_getoptions_installed() {
  local getoptions_path="/usr/local/bin/getoptions"
  
  if [[ -f "$getoptions_path" ]] && command -v getoptions >/dev/null 2>&1; then
    local current_version
    current_version=$(getoptions --version 2>/dev/null | grep -o 'v[0-9.]*' | head -1 || echo "unknown")
    echo "‚úÖ getoptions is already installed (version: $current_version)"
    _log_has_getoptions=true
    return 0
  fi
  
  echo "getoptions not found. Installing..."
  
  # Check sudo requirement instead of installing sudo
  if ! check_sudo_requirement; then
    echo "‚ùå Cannot install getoptions without proper permissions"
    _log_has_getoptions=false
    return 1
  fi
  
  # Determine if we need sudo prefix for commands
  local sudo_cmd=""
  if [[ $EUID -ne 0 ]]; then
    sudo_cmd="sudo "
  fi
  
  # Download getoptions from GitHub
  local target_version="${GETOPTIONS_VERSION:-latest}"
  local version_to_use
  
  if [[ "$target_version" == "latest" ]]; then
    version_to_use=$(curl -s https://api.github.com/repos/ko1nksm/getoptions/releases/latest | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')
    if [[ -z "$version_to_use" ]]; then
      echo "‚ö†Ô∏è Failed to get latest version, using fallback"
      version_to_use="v3.3.0"  # Known working version
    fi
  else
    version_to_use="$target_version"
    [[ "$version_to_use" != v* ]] && version_to_use="v${version_to_use}"
  fi
  
  echo "Installing getoptions version: $version_to_use"
  
  local download_url="https://github.com/ko1nksm/getoptions/releases/download/${version_to_use}/getoptions"
  local temp_file="/tmp/getoptions-$$"
  
  if curl -sL "$download_url" -o "$temp_file"; then
    if [[ -f "$temp_file" ]] && [[ -s "$temp_file" ]]; then
      if ${sudo_cmd}mv "$temp_file" "$getoptions_path" && ${sudo_cmd}chmod +x "$getoptions_path"; then
        _log_has_getoptions=true
        echo "‚úÖ getoptions $version_to_use installed successfully"
        return 0
      else
        echo "‚ö†Ô∏è Failed to install getoptions"
        echo "üóëÔ∏è Cleaning up temporary file..."
        rm -f "$temp_file"
      fi
    else
      echo "‚ö†Ô∏è Downloaded getoptions file is empty"
      echo "üóëÔ∏è Cleaning up empty file..."
      rm -f "$temp_file"
    fi
  else
    echo "‚ö†Ô∏è Failed to download getoptions"
  fi
  
  _log_has_getoptions=false
  echo "‚ö†Ô∏è getoptions installation failed, using builtin option parsing"
}

#################################################################
# CORE INITIALIZATION SYSTEM
#################################################################

# Initialize logging system (called once for performance)
_log_init() {
  if [[ "$_log_initialized" == "true" ]]; then
    return 0
  fi
  
  # Cache module name
  _log_module="${LOG_MODULE:-SYSTEM}"
  
  # Cache quiet mode
  local quiet="${LOG_QUIET:-false}"
  if [[ "$quiet" == "true" || "$quiet" == "1" || "$quiet" =~ ^(yes|YES)$ ]]; then
    _log_quiet_mode=true
  else
    _log_quiet_mode=false
  fi
  
  # Cache debug mode
  local debug="${LOG_DEBUG:-false}"
  if [[ "$debug" == "true" || "$debug" == "1" || "$debug" =~ ^(yes|YES)$ ]]; then
    _log_debug_mode=true
  elif [[ "${LOG_LEVEL:-}" == "DEBUG" ]]; then
    # Auto-enable debug mode when log level is DEBUG
    _log_debug_mode=true
  else
    _log_debug_mode=false
  fi
  
  # Check dependencies
  ensure_gum_installed
  ensure_getoptions_installed
  
  _log_initialized=true
}

# Update debug mode after option parsing
_update_debug_mode() {
  local debug="${LOG_DEBUG:-false}"
  if [[ "$debug" == "true" || "$debug" == "1" || "$debug" =~ ^(yes|YES)$ ]]; then
    _log_debug_mode=true
  elif [[ "${LOG_LEVEL:-}" == "DEBUG" ]]; then
    # Auto-enable debug mode when log level is DEBUG
    _log_debug_mode=true
  else
    _log_debug_mode=false
  fi
}

# Update cached values after option parsing
_update_cached_values() {
  _update_debug_mode
  _log_module="${LOG_MODULE:-SYSTEM}"
}

# Get current log level priority
_get_log_level_priority() {
  local level="$1"
  echo "${LOG_LEVEL_PRIORITIES[$level]:-20}"
}

# Check if message should be logged based on level
_should_log() {
  local level="$1"
  local min_level="${LOG_LEVEL:-INFO}"
  
  local current_priority
  local min_priority
  
  current_priority=$(_get_log_level_priority "$level")
  min_priority=$(_get_log_level_priority "$min_level")
  
  [[ $current_priority -ge $min_priority ]]
}

#################################################################
# OPTIMIZED LOGGING CORE
#################################################################

# High-performance core logging function
_log_core() {
  local level="$1"
  local message="$2"
  local use_stderr="${3:-false}"
  
  # Early exit conditions (performance optimization)
  if [[ "$_log_quiet_mode" == "true" ]]; then
    return 0
  fi
  
  if [[ "$level" == "DEBUG" && "$_log_debug_mode" != "true" ]]; then
    return 0
  fi
  
  if ! _should_log "$level"; then
    return 0
  fi
  
  # Format timestamp
  local timestamp
  timestamp=$(date +"${LOG_TIME_FORMAT:-%H:%M:%S}")
  
  # Choose output method based on gum availability
  if [[ "$_log_has_gum" == "true" ]]; then
    _log_with_gum "$level" "$message" "$timestamp" "$use_stderr"
  else
    _log_fallback "$level" "$message" "$timestamp" "$use_stderr"
  fi
  
  # Log to file if configured
  if [[ -n "${LOG_FILE:-}" ]]; then
    _log_to_file "$level" "$message" "$timestamp"
  fi
}

# Gum-optimized logging
_log_with_gum() {
  local level="$1"
  local message="$2"
  local timestamp="$3"
  local use_stderr="$4"
  
  local color="${GUM_COLORS[$level]:-${GUM_COLORS[INFO]}}"
  
  # Map levels to gum-compatible levels
  local gum_level
  case "$level" in
    "INFO") gum_level="info" ;;
    "WARN") gum_level="warn" ;;
    "ERROR") gum_level="error" ;;
    "DEBUG") gum_level="debug" ;;
    "SUCCESS"|"STEP") gum_level="info" ;;
    *) gum_level="info" ;;
  esac
  
  local cmd=(
    gum log
    --structured
    --level="$gum_level"
    --time="datetime"
    --prefix="$_log_module"
    --level.foreground="$color"
    --time.foreground="${GUM_COLORS[TIME]}"
    --prefix.foreground="${GUM_COLORS[MODULE]}"
    --message.foreground="${GUM_COLORS[MESSAGE]}"
  )
  
  if [[ "$use_stderr" == "true" ]]; then
    "${cmd[@]}" "$message" >&2
  else
    "${cmd[@]}" "$message"
  fi
}

# Fallback logging without gum
_log_fallback() {
  local level="$1"
  local message="$2"
  local timestamp="$3"
  local use_stderr="$4"
  
  local color_name
  case "$level" in
    "INFO") color_name="BLUE" ;;
    "WARN") color_name="YELLOW" ;;
    "ERROR") color_name="RED" ;;
    "SUCCESS") color_name="GREEN" ;;
    "STEP") color_name="PURPLE" ;;
    "DEBUG") color_name="CYAN" ;;
    *) color_name="WHITE" ;;
  esac
  
  local output
  if [[ "${LOG_ENABLE_COLORS:-true}" == "true" ]]; then
    output="${LOG_COLORS[$color_name]}$timestamp $level $_log_module: ${LOG_COLORS[RESET]}$message"
  else
    output="$timestamp $level $_log_module: $message"
  fi
  
  if [[ "$use_stderr" == "true" ]]; then
    echo -e "$output" >&2
  else
    echo -e "$output"
  fi
}

# File logging with rotation support
_log_to_file() {
  local level="$1"
  local message="$2"
  local timestamp="$3"
  local file_timestamp
  
  file_timestamp=$(date '+%Y-%m-%d %H:%M:%S')
  
  # Check file size and rotate if needed
  if [[ -f "${LOG_FILE}" ]] && [[ "${LOG_ROTATION:-true}" == "true" ]]; then
    _rotate_log_if_needed
  fi
  
  echo "[$file_timestamp] [$level] [$_log_module] $message" >> "${LOG_FILE}"
}

# Log rotation implementation
_rotate_log_if_needed() {
  local max_size="${LOG_MAX_SIZE:-10M}"
  local max_files="${LOG_MAX_FILES:-5}"
  
  # Convert size to bytes for comparison
  local max_bytes
  case "${max_size: -1}" in
    "K"|"k") max_bytes=$((${max_size%?} * 1024)) ;;
    "M"|"m") max_bytes=$((${max_size%?} * 1024 * 1024)) ;;
    "G"|"g") max_bytes=$((${max_size%?} * 1024 * 1024 * 1024)) ;;
    *) max_bytes="${max_size}" ;;
  esac
  
  local current_size
  current_size=$(stat -f%z "${LOG_FILE}" 2>/dev/null || stat -c%s "${LOG_FILE}" 2>/dev/null || echo 0)
  
  if [[ $current_size -gt $max_bytes ]]; then
    # Rotate files
    for ((i=max_files; i>=1; i--)); do
      if [[ -f "${LOG_FILE}.$i" ]]; then
        if [[ $i -eq $max_files ]]; then
          rm -f "${LOG_FILE}.$i"
        else
          mv "${LOG_FILE}.$i" "${LOG_FILE}.$((i+1))"
        fi
      fi
    done
    
    mv "${LOG_FILE}" "${LOG_FILE}.1"
    touch "${LOG_FILE}"
  fi
}

#################################################################
# PUBLIC LOGGING FUNCTIONS
#################################################################

# Initialize the logging system
log_init() {
  _log_init
}

# Core logging functions (optimized)
log_info() {
  _log_init
  _log_core "INFO" "$*"
}

log_warn() {
  _log_init
  _log_core "WARN" "$*"
}

log_error() {
  _log_init
  _log_core "ERROR" "$*" true
}

log_success() {
  _log_init
  _log_core "SUCCESS" "$*"
}

log_step() {
  _log_init
  _log_core "STEP" "$*"
}

log_debug() {
  _log_init
  _log_core "DEBUG" "$*"
}

# Shorter aliases for convenience
info() { log_info "$@"; }
warn() { log_warn "$@"; }
error() { log_error "$@"; }
success() { log_success "$@"; }
step() { log_step "$@"; }
# Note: debug() alias removed to avoid conflict with debug command

#################################################################
# ADVANCED LOGGING FUNCTIONS
#################################################################

# Structured logging with key-value pairs
log_structured() {
  _log_init
  local level="${1:-info}"
  shift
  
  if [[ "$_log_quiet_mode" == "true" ]]; then
    return 0
  fi
  
  if [[ "$_log_has_gum" == "true" ]]; then
    local color="${GUM_COLORS[${level^^}]:-${GUM_COLORS[INFO]}}"
    
    # Map levels to gum-compatible levels
    local gum_level
    case "${level^^}" in
      "INFO") gum_level="info" ;;
      "WARN") gum_level="warn" ;;
      "ERROR") gum_level="error" ;;
      "DEBUG") gum_level="debug" ;;
      "SUCCESS"|"STEP") gum_level="info" ;;
      *) gum_level="info" ;;
    esac
    
    gum log \
      --structured \
      --level="$gum_level" \
      --time="datetime" \
      --prefix="$_log_module" \
      --level.foreground="$color" \
      --time.foreground="${GUM_COLORS[TIME]}" \
      --prefix.foreground="${GUM_COLORS[MODULE]}" \
      --key.foreground="#ff69b4" \
      --value.foreground="#ffffff" \
      --separator.foreground="#666666" \
      "$@"
  else
    local color_name
    case "${level^^}" in
      "ERROR") color_name="RED" ;;
      "WARN") color_name="YELLOW" ;;
      "INFO") color_name="BLUE" ;;
      "DEBUG") color_name="CYAN" ;;
      *) color_name="WHITE" ;;
    esac
    
    local timestamp
    timestamp=$(date +"${LOG_TIME_FORMAT:-%H:%M:%S}")
    
    # Format structured data properly
    local formatted_args=""
    for arg in "$@"; do
      if [[ "$arg" =~ ^([^=]+)=(.*)$ ]]; then
        local key="${BASH_REMATCH[1]}"
        local value="${BASH_REMATCH[2]}"
        formatted_args+="${key}=${value} "
      else
        formatted_args+="$arg "
      fi
    done
    
    echo -e "${LOG_COLORS[$color_name]}$timestamp ${level^^} $_log_module: ${LOG_COLORS[RESET]}${formatted_args% }"
  fi
}

# Progress indicator with spinner
log_progress() {
  _log_init
  local title="$1"
  local command="$2"
  
  if [[ "$_log_quiet_mode" == "true" ]]; then
    eval "$command"
    return $?
  fi
  
  if [[ "$_log_has_gum" == "true" ]]; then
    gum spin --spinner="dot" --title="$title" -- bash -c "$command"
  else
    log_info "$title"
    eval "$command"
  fi
}

# Visual elements
log_separator() {
  _log_init
  if [[ "$_log_quiet_mode" == "true" ]]; then
    return 0
  fi
  
  if [[ "$_log_has_gum" == "true" ]]; then
    gum style --foreground="#666666" "$(printf '%.0s‚îÄ' {1..80})"
  else
    echo -e "${LOG_COLORS[GRAY]}$(printf '%.0s‚îÄ' {1..80})${LOG_COLORS[RESET]}"
  fi
}

log_banner() {
  _log_init
  local title="$1"
  local subtitle="${2:-}"
  
  if [[ "$_log_quiet_mode" == "true" ]]; then
    return 0
  fi
  
  if [[ "$_log_has_gum" == "true" ]]; then
    echo
    gum style \
      --foreground="#00d7ff" \
      --border="rounded" \
      --padding="1 2" \
      --margin="1 0" \
      --bold \
      "$title" ${subtitle:+"$subtitle"}
    echo
  else
    echo
    local border_len=$((${#title} + 4))
    echo -e "${LOG_COLORS[BLUE]}${LOG_COLORS[BOLD]}‚ï≠$(printf '%.0s‚îÄ' $(seq 1 $border_len))‚ïÆ${LOG_COLORS[RESET]}"
    echo -e "${LOG_COLORS[BLUE]}${LOG_COLORS[BOLD]}‚îÇ $title ‚îÇ${LOG_COLORS[RESET]}"
    if [[ -n "$subtitle" ]]; then
      echo -e "${LOG_COLORS[BLUE]}${LOG_COLORS[BOLD]}‚îÇ $subtitle ‚îÇ${LOG_COLORS[RESET]}"
    fi
    echo -e "${LOG_COLORS[BLUE]}${LOG_COLORS[BOLD]}‚ï∞$(printf '%.0s‚îÄ' $(seq 1 $border_len))‚ïØ${LOG_COLORS[RESET]}"
    echo
  fi
}

#################################################################
# TEMPLATE SYSTEM
#################################################################

# Template with variable substitution
log_template() {
  local template_str="$1"
  shift
  local variables=("$@")
  
  # Efficient variable substitution
  local result="$template_str"
  for var in "${variables[@]}"; do
    if [[ "$var" =~ ^([^=]+)=(.*)$ ]]; then
      local key="${BASH_REMATCH[1]}"
      local value="${BASH_REMATCH[2]}"
      result="${result//\{\{.$key\}\}/$value}"
    fi
  done
  
  # Apply gum formatting if available
  if [[ "$_log_has_gum" == "true" ]]; then
    echo "$result" | gum format --type="markdown" --theme="${LOG_THEME:-pink}"
  else
    echo "$result"
  fi
}

# Template with logging integration
log_template_message() {
  _log_init
  local level="$1"
  local template_str="$2"
  shift 2
  
  if [[ "$_log_quiet_mode" == "true" ]]; then
    return 0
  fi
  
  local formatted_message
  formatted_message=$(log_template "$template_str" "$@")
  
  case "$level" in
    "info") log_info "$formatted_message" ;;
    "warn") log_warn "$formatted_message" ;;
    "error") log_error "$formatted_message" ;;
    "success") log_success "$formatted_message" ;;
    "step") log_step "$formatted_message" ;;
    "debug") log_debug "$formatted_message" ;;
    *) log_info "$formatted_message" ;;
  esac
}

#################################################################
# CONFIGURATION MANAGEMENT
#################################################################

# Set configuration values
log_config_set() {
  local key="$1"
  local value="$2"
  
  case "$key" in
    "level") export LOG_LEVEL="$value" ;;
    "file") export LOG_FILE="$value" ;;
    "format") export LOG_FORMAT="$value" ;;
    "theme") export LOG_THEME="$value" ;;
    "time_format") export LOG_TIME_FORMAT="$value" ;;
    "rotation") export LOG_ROTATION="$value" ;;
    "max_size") export LOG_MAX_SIZE="$value" ;;
    "max_files") export LOG_MAX_FILES="$value" ;;
    "colors") export LOG_ENABLE_COLORS="$value" ;;
    "quiet") 
      export LOG_QUIET="$value"
      _log_quiet_mode="$value"
      ;;
    "debug") 
      export LOG_DEBUG="$value"
      _log_debug_mode="$value"
      ;;
    "module")
      export LOG_MODULE="$value"
      _log_module="$value"
      ;;
    *) 
      log_error "Unknown configuration key: $key"
      return 1
      ;;
  esac
}

# Get configuration values
log_config_get() {
  local key="$1"
  
  case "$key" in
    "level") echo "${LOG_LEVEL:-${LOG_DEFAULTS[level]}}" ;;
    "file") echo "${LOG_FILE:-${LOG_DEFAULTS[file]}}" ;;
    "format") echo "${LOG_FORMAT:-${LOG_DEFAULTS[format]}}" ;;
    "theme") echo "${LOG_THEME:-${LOG_DEFAULTS[theme]}}" ;;
    "time_format") echo "${LOG_TIME_FORMAT:-${LOG_DEFAULTS[time_format]}}" ;;
    "rotation") echo "${LOG_ROTATION:-${LOG_DEFAULTS[rotation]}}" ;;
    "max_size") echo "${LOG_MAX_SIZE:-${LOG_DEFAULTS[max_size]}}" ;;
    "max_files") echo "${LOG_MAX_FILES:-${LOG_DEFAULTS[max_files]}}" ;;
    "colors") echo "${LOG_ENABLE_COLORS:-${LOG_DEFAULTS[colors]}}" ;;
    "quiet") echo "${LOG_QUIET:-${LOG_DEFAULTS[quiet]}}" ;;
    "debug") echo "${LOG_DEBUG:-${LOG_DEFAULTS[debug]}}" ;;
    "module") echo "${LOG_MODULE:-${LOG_DEFAULTS[module]}}" ;;
    "version") echo "$SCRIPT_VERSION" ;;
    "build") echo "$SCRIPT_BUILD" ;;
    "has_gum") echo "$_log_has_gum" ;;
    "has_getoptions") echo "$_log_has_getoptions" ;;
    "os") detect_os ;;
    "package_manager") get_package_manager ;;
    *) 
      log_error "Unknown configuration key: $key"
      return 1
      ;;
  esac
}

# Show current configuration
log_config_show() {
  _log_init
  
  log_banner "$SCRIPT_DESCRIPTION Configuration" "v$SCRIPT_VERSION"
  
  log_info "üîß Core Settings:"
  local file_value="${LOG_FILE:-none}"
  log_structured info "level=$(log_config_get level)" "file=$file_value" "format=$(log_config_get format)"
  
  log_info "üé® Display Settings:"
  log_structured info "theme=$(log_config_get theme)" "colors=$(log_config_get colors)" "time_format=$(log_config_get time_format)"
  
  log_info "üìÅ File Settings:"
  log_structured info "rotation=$(log_config_get rotation)" "max_size=$(log_config_get max_size)" "max_files=$(log_config_get max_files)"
  
  log_info "‚öôÔ∏è  Runtime Settings:"
  log_structured info "module=$(log_config_get module)" "quiet=$(log_config_get quiet)" "debug=$(log_config_get debug)"
  
  log_info "üîå Dependencies:"
  log_structured info "has_gum=$(log_config_get has_gum)" "has_getoptions=$(log_config_get has_getoptions)"
  
  log_info "üñ•Ô∏è  System Info:"
  log_structured info "os=$(log_config_get os)" "package_manager=$(log_config_get package_manager)"
  
  log_separator
}

# Reset configuration to defaults
log_config_reset() {
  for key in "${!LOG_DEFAULTS[@]}"; do
    log_config_set "$key" "${LOG_DEFAULTS[$key]}"
  done
  log_success "Configuration reset to defaults"
}

#################################################################
# UTILITY FUNCTIONS
#################################################################

# Performance benchmark
log_benchmark() {
  _log_init
  
  log_banner "Logging Performance Benchmark"
  
  local iterations=100
  local start_time end_time duration
  
  log_info "Running $iterations iterations..."
  
  # Test info logging
  start_time=$(date +%s)
  for ((i=1; i<=iterations; i++)); do
    log_info "Benchmark message $i" >/dev/null 2>&1
  done
  end_time=$(date +%s)
  duration=$((end_time - start_time))
  
  if [[ $duration -eq 0 ]]; then
    duration=1  # Prevent division by zero
  fi
  
  local rate=$((iterations / duration))
  
  log_structured info "test=info_logging" "iterations=$iterations" "duration=${duration}s" "rate=${rate}/s"
  
  log_separator
  log_success "Benchmark completed"
}

# Version information
log_version() {
  echo "$SCRIPT_DESCRIPTION v$SCRIPT_VERSION (build $SCRIPT_BUILD)"
  echo "Gum support: $_log_has_gum"
  echo "getoptions support: $_log_has_getoptions"
  echo "Operating System: $(detect_os)"
  echo "Package Manager: $(get_package_manager)"
  echo "Author: $SCRIPT_AUTHOR"
  echo "License: $SCRIPT_LICENSE"
}

#################################################################
# OPTION PARSING WITH GETOPTIONS SUPPORT
#################################################################

# getoptions parser specification
parser_definition() {
  # Only define parser if getoptions is loaded
  if ! command -v setup >/dev/null 2>&1; then
    return 1
  fi
  
  setup   REST help:usage abbr:true -- \
    "Usage: ${0##*/} [COMMAND] [OPTIONS] [MESSAGE]"
  msg -- 'COMMANDS:'
  msg -- '  Log Commands:'
  msg -- '    info <message>       Log an info message'
  msg -- '    warn <message>       Log a warning message'
  msg -- '    error <message>      Log an error message'
  msg -- '    success <message>    Log a success message'
  msg -- '    step <message>       Log a step message'
  msg -- '    debug <message>      Log a debug message'
  msg -- ''
  msg -- '  Structured Logging:'
  msg -- '    structured <level> <key=value> [key=value]...   Log key-value pairs'
  msg -- '    template <level> <template> <key=value> [key=value]...   Template logging'
  msg -- ''
  msg -- '  Visual Elements:'
  msg -- '    banner <title> [subtitle]    Show a banner'
  msg -- '    separator                    Show a separator line'
  msg -- '    progress <title> <command>   Show progress with spinner'
  msg -- ''
  msg -- '  Configuration:'
  msg -- '    config [key] [value]         Get/set configuration'
  msg -- '    show-config                  Show current configuration'
  msg -- '    reset-config                 Reset to default configuration'
  msg -- ''
  msg -- '  Utility:'
  msg -- '    benchmark                    Run performance benchmark'
  msg -- '    test                        Run functionality tests'
  msg -- '    demo                        Show demonstration'
  msg -- '    install-deps                Install missing dependencies'
  msg -- '    version                     Show version information'
  msg -- '    help                        Show this help'
  msg -- ''
  msg -- 'OPTIONS:'
  option  LOG_FILE          -f --file          -- "Set log file path"
  option  LOG_LEVEL         -l --level         -- "Set minimum log level (DEBUG|INFO|WARN|ERROR)"
  option  LOG_FORMAT           --format        -- "Set log format (gum|plain)"
  option  LOG_THEME            --theme         -- "Set gum theme (pink|dark|light)"
  option  LOG_MODULE        -m --module        -- "Set module name"
  flag    LOG_QUIET         -q --quiet         -- "Enable quiet mode"
  flag    LOG_DEBUG         -d --debug         -- "Enable debug mode"
  flag    LOG_NO_COLORS        --no-colors     -- "Disable colors"
  option  LOG_TIME_FORMAT      --time-format   -- "Set time format (default: %Y-%m-%d %H:%M:%S)"
  flag    show_help         -h --help          -- "Show help"
  flag    show_version      -V --version       -- "Show version"
}

# Fallback option parsing for when getoptions is not available
parse_options_fallback() {
  local remaining_args=()
  
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -f|--file)
        if [[ -z "${2:-}" ]]; then
          log_error "Option --file requires a value"
          exit 1
        fi
        LOG_FILE="$2"
        shift 2
        ;;
      -l|--level)
        if [[ -z "${2:-}" ]]; then
          log_error "Option --level requires a value"
          exit 1
        fi
        LOG_LEVEL="${2^^}"
        shift 2
        ;;
      --format)
        if [[ -z "${2:-}" ]]; then
          log_error "Option --format requires a value"
          exit 1
        fi
        LOG_FORMAT="$2"
        shift 2
        ;;
      --theme)
        if [[ -z "${2:-}" ]]; then
          log_error "Option --theme requires a value"
          exit 1
        fi
        LOG_THEME="$2"
        shift 2
        ;;
      -m|--module)
        if [[ -z "${2:-}" ]]; then
          log_error "Option --module requires a value"
          exit 1
        fi
        LOG_MODULE="$2"
        shift 2
        ;;
      -q|--quiet)
        LOG_QUIET="true"
        shift
        ;;
      -d|--debug)
        LOG_DEBUG="true"
        shift
        ;;
      --no-colors)
        LOG_ENABLE_COLORS="false"
        shift
        ;;
      --time-format)
        if [[ -z "${2:-}" ]]; then
          log_error "Option --time-format requires a value"
          exit 1
        fi
        LOG_TIME_FORMAT="$2"
        shift 2
        ;;
      -h|--help)
        show_help_fallback
        exit 0
        ;;
      -V|--version)
        log_version
        exit 0
        ;;
      -*)
        log_error "Unknown option: $1"
        echo "Use '$SCRIPT_NAME --help' for usage information."
        exit 1
        ;;
      *)
        # Add non-option arguments to remaining args
        remaining_args+=("$1")
        shift
        ;;
    esac
  done
  
  # Return remaining arguments  
  if [[ ${#remaining_args[@]} -gt 0 ]]; then
    printf '%q ' "${remaining_args[@]}"
  fi
}

# Fallback help when getoptions is not available
show_help_fallback() {
  cat << 'EOF'
LaraGIS Enhanced Logging CLI Tool v4.0.0

USAGE:
  log [COMMAND] [OPTIONS] [MESSAGE]

COMMANDS:
  Log Commands:
    info <message>       Log an info message
    warn <message>       Log a warning message
    error <message>      Log an error message
    success <message>    Log a success message
    step <message>       Log a step message
    debug <message>      Log a debug message (requires --debug)
    
  Structured Logging:
    structured <level> <key=value> [key=value]...   Log key-value pairs
    template <level> <template> <key=value> [key=value]...   Template logging
    
  Visual Elements:
    banner <title> [subtitle]    Show a banner
    separator                    Show a separator line
    progress <title> <command>   Show progress with spinner
    
  Configuration:
    config [key] [value]         Get/set configuration
    show-config                  Show current configuration
    reset-config                 Reset to default configuration
    
  Utility:
    benchmark                    Run performance benchmark
    test                        Run functionality tests
    demo                        Show demonstration
    install-deps                Install missing dependencies
    version                     Show version information
    help                        Show this help

OPTIONS:
  -f, --file <path>         Set log file path
  -l, --level <level>       Set minimum log level (DEBUG|INFO|WARN|ERROR)
      --format <format>     Set log format (gum|plain)
      --theme <theme>       Set gum theme (pink|dark|light)
  -m, --module <name>       Set module name
  -q, --quiet               Enable quiet mode
  -d, --debug               Enable debug mode
      --no-colors           Disable colors
      --time-format <fmt>   Set time format (default: %Y-%m-%d %H:%M:%S)
  -h, --help                Show help
  -V, --version             Show version

EXAMPLES:
  # Basic logging
  log info "Application started"
  log error "Connection failed"
  
  # Configuration
  log config level DEBUG
  log config file "/var/log/app.log"
  
  # Structured logging
  log structured info "status=running" "cpu=45%" "memory=2GB"
  
  # Template logging
  log template info "Deploy {{.Status}} for {{.App}}" "Status=success" "App=MyApp"
  
  # Visual elements
  log banner "System Status" "All services running"
  log progress "Installing packages" "sleep 3"
  
  # Set options and log
  log --module "DEPLOY" --debug info "Debug enabled"
  
  # File logging
  log --file "/tmp/test.log" info "Logged to file"

ENVIRONMENT VARIABLES:
  LOG_MODULE              Set default module name
  LOG_QUIET               Enable quiet mode (true/false)
  LOG_DEBUG               Enable debug mode (true/false)
  LOG_ENABLE_COLORS       Enable colors (true/false)
  LOG_LEVEL               Set minimum log level
  LOG_FILE                Set default log file
  LOG_THEME               Set default gum theme
  GUM_VERSION             Set gum version to install (default: latest)
  GETOPTIONS_VERSION      Set getoptions version to install (default: latest)

EXAMPLES:
  # Install specific gum version
  GUM_VERSION=0.16.0 log install-deps
  
  # Install specific versions
  GUM_VERSION=v0.15.0 GETOPTIONS_VERSION=v3.2.0 log install-deps

EOF
}

#################################################################
# COMMAND HANDLERS
#################################################################

handle_log_command() {
  local level="$1"
  shift
  local message="$*"
  
  if [[ -z "$message" ]]; then
    log_error "Message is required for log command"
    return 1
  fi
  
  case "$level" in
    "info") log_info "$message" ;;
    "warn") log_warn "$message" ;;
    "error") log_error "$message" ;;
    "success") log_success "$message" ;;
    "step") log_step "$message" ;;
    "debug") log_debug "$message" ;;
    *) log_error "Unknown log level: $level"; return 1 ;;
  esac
}

handle_structured_command() {
  local level="$1"
  shift
  
  if [[ $# -eq 0 ]]; then
    log_error "Key-value pairs are required"
    return 1
  fi
  
  log_structured "$level" "$@"
}

handle_template_command() {
  local level="$1"
  local template_str="$2"
  shift 2
  
  if [[ -z "$template_str" ]]; then
    log_error "Template string is required"
    return 1
  fi
  
  log_template_message "$level" "$template_str" "$@"
}

handle_config_command() {
  local key="${1:-}"
  local value="${2:-}"
  
  if [[ -z "$key" ]]; then
    log_config_show
    return 0
  fi
  
  if [[ -z "$value" ]]; then
    log_config_get "$key"
  else
    log_config_set "$key" "$value"
    log_success "Configuration updated: $key = $value"
  fi
}

handle_banner_command() {
  local title="$1"
  local subtitle="${2:-}"
  
  if [[ -z "$title" ]]; then
    log_error "Title is required for banner"
    return 1
  fi
  
  log_banner "$title" "$subtitle"
}

handle_progress_command() {
  local title="$1"
  local command="$2"
  
  if [[ -z "$title" || -z "$command" ]]; then
    log_error "Title and command are required for progress"
    return 1
  fi
  
  log_progress "$title" "$command"
}

#################################################################
# TEST AND DEMO FUNCTIONS
#################################################################

run_comprehensive_tests() {
  local failed=0
  local test_start_time
  test_start_time=$(date +%s)
  
  log_banner "$SCRIPT_DESCRIPTION Tests" "Running comprehensive test suite v$SCRIPT_VERSION"
  
  # Test system detection
  log_step "1. Testing system detection..."
  local os_detected
  os_detected=$(detect_os)
  local pm_detected
  pm_detected=$(get_package_manager)
  log_structured info "os=$os_detected" "package_manager=$pm_detected"
  
  # Test basic logging functions
  log_step "2. Testing basic logging functions..."
  log_info "‚úÖ Test info message"
  log_warn "‚ö†Ô∏è Test warning message"
  log_success "‚úÖ Test success message"
  log_error "‚ùå Test error message" 2>/dev/null || true
  
  # Test debug logging
  log_step "3. Testing debug logging..."
  local old_debug="${LOG_DEBUG:-false}"
  LOG_DEBUG="true"
  _log_debug_mode="true"
  log_debug "üêõ Test debug message (should show)"
  LOG_DEBUG="false"
  _log_debug_mode="false"
  log_debug "üêõ Test debug message (should not show)"
  LOG_DEBUG="$old_debug"
  
  # Test structured logging
  log_step "4. Testing structured logging..."
  log_structured info "test=passed" "component=structured_logging" "performance=excellent" "timestamp=$(date)"
  
  # Test template logging
  log_step "5. Testing template logging..."
  log_template_message info "Test {{.Status}} for {{.Component}} v{{.Version}}" \
    "Status=‚úÖ passed" \
    "Component=template system" \
    "Version=$SCRIPT_VERSION"
  
  # Test visual elements
  log_step "6. Testing visual elements..."
  log_separator
  log_banner "Test Banner" "Testing visual elements"
  
  # Test configuration management
  log_step "7. Testing configuration management..."
  log_config_set "module" "TEST"
  local module_value
  module_value=$(log_config_get "module")
  if [[ "$module_value" == "TEST" ]]; then
    log_success "‚úÖ Configuration test passed"
  else
    log_error "‚ùå Configuration test failed"
    ((failed++))
  fi
  
  # Test file logging
  log_step "8. Testing file logging..."
  local test_file="/tmp/log-test-$$.log"
  log_config_set "file" "$test_file"
  log_info "Test file logging message"
  
  if [[ -f "$test_file" ]]; then
    local content
    content=$(cat "$test_file")
    if [[ "$content" == *"Test file logging message"* ]]; then
      log_success "‚úÖ File logging test passed"
    else
      log_error "‚ùå File logging test failed - content not found"
      ((failed++))
    fi
    rm -f "$test_file"
  else
    log_error "‚ùå File logging test failed - file not created"
    ((failed++))
  fi
  
  # Test dependency detection
  log_step "9. Testing dependency detection..."
  log_structured info "gum_available=$_log_has_gum" "getoptions_available=$_log_has_getoptions"
  
  # Test performance
  log_step "10. Testing performance..."
  local perf_start perf_end perf_duration
  perf_start=$(date +%s)
  for ((i=1; i<=50; i++)); do
    log_info "Performance test message $i" >/dev/null 2>&1
  done
  perf_end=$(date +%s)
  perf_duration=$((perf_end - perf_start))
  [[ $perf_duration -eq 0 ]] && perf_duration=1
  local perf_rate=$((50 / perf_duration))
  log_structured info "performance_test=completed" "iterations=50" "duration=${perf_duration}s" "rate=${perf_rate}/s"
  
  log_separator
  
  local total_duration=$(($(date +%s) - test_start_time))
  
  if [[ $failed -eq 0 ]]; then
    log_success "üéâ All tests passed! (${total_duration}s total)"
  else
    log_error "‚ùå $failed test(s) failed (${total_duration}s total)"
    return 1
  fi
}

run_feature_demo() {
  local demo_start_time
  demo_start_time=$(date +%s)
  
  log_banner "$SCRIPT_DESCRIPTION Demo" "Showcasing all features and capabilities v$SCRIPT_VERSION"
  
  # System information
  log_step "üñ•Ô∏è  System Information"
  log_structured info \
    "os=$(detect_os)" \
    "package_manager=$(get_package_manager)" \
    "gum_available=$_log_has_gum" \
    "getoptions_available=$_log_has_getoptions"
  
  log_separator
  
  # Basic logging demo
  log_step "üìù 1. Basic Logging Functions"
  log_info "üì¢ This is an informational message"
  log_warn "‚ö†Ô∏è This is a warning message"
  log_success "‚úÖ This is a success message"
  log_error "‚ùå This is an error message" 2>/dev/null || true
  
  log_separator
  
  # Debug logging demo
  log_step "üêõ 2. Debug Logging (conditional)"
  log_debug "üêõ Debug message (hidden by default)"
  local old_debug="${LOG_DEBUG:-false}"
  LOG_DEBUG="true"
  _log_debug_mode="true"
  log_debug "üêõ Debug message (now visible with DEBUG=true)"
  LOG_DEBUG="$old_debug"
  _log_debug_mode="false"
  
  log_separator
  
  # Structured logging demo
  log_step "üìä 3. Structured Logging with Key-Value Pairs"
  log_structured info \
    "application=demo" \
    "status=running" \
    "cpu_usage=45%" \
    "memory=2.1GB" \
    "uptime=24h" \
    "timestamp=$(date)"
  
  log_structured warn \
    "disk_usage=85%" \
    "threshold=80%" \
    "action=cleanup_required" \
    "priority=high"
  
  log_structured error \
    "service=database" \
    "status=connection_failed" \
    "retry_count=3" \
    "last_error=timeout"
  
  log_separator
  
  # Template logging demo
  log_step "üîß 4. Template Logging with Variables"
  log_template_message info \
    "üöÄ Deployment {{.Status}} for {{.Application}} v{{.Version}}" \
    "Status=completed successfully" \
    "Application=LaraGIS Container" \
    "Version=$SCRIPT_VERSION"
    
  log_template_message success \
    "‚ö° Performance: {{.ResponseTime}}ms avg, {{.Throughput}} req/s, {{.Uptime}} uptime" \
    "ResponseTime=45" \
    "Throughput=1250" \
    "Uptime=99.9%"
  
  log_separator
  
  # Visual elements demo
  log_step "üé® 5. Visual Elements"
  log_banner "System Health Status" "All services operational ‚úÖ"
  log_separator
  
  # Progress demo
  log_step "‚è≥ 6. Progress Indicators"
  log_progress "üîÑ Simulating package installation..." "sleep 2"
  log_progress "üîß Configuring services..." "sleep 1"
  log_progress "‚úÖ Finalizing setup..." "sleep 1"
  
  log_separator
  
  # Configuration demo
  log_step "‚öôÔ∏è  7. Configuration Management"
  local old_module="$_log_module"
  log_config_set "module" "DEMO"
  log_info "Module set to: $(log_config_get module)"
  
  log_config_set "level" "DEBUG"
  log_info "Log level set to: $(log_config_get level)"
  log_debug "üêõ Debug message now visible due to level change"
  
  # Restore original module
  log_config_set "module" "$old_module"
  
  log_separator
  
  # File logging demo
  log_step "üìÅ 8. File Logging with Rotation"
  local demo_file="/tmp/demo-log-$$.log"
  log_config_set "file" "$demo_file"
  log_info "üìù This message is logged to file: $demo_file"
  log_warn "üìù This warning is also logged to file"
  
  if [[ -f "$demo_file" ]]; then
    log_success "‚úÖ File logging verified:"
    echo "    $(cat "$demo_file" | head -2 | sed 's/^/    /')"
    rm -f "$demo_file"
  fi
  
  # Reset file logging
  log_config_set "file" ""
  
  log_separator
  
  # Advanced features demo
  log_step "üéõÔ∏è  9. Advanced Features"
  
  # Banner variations
  log_banner "System Status Dashboard"
  log_banner "Alert" "High CPU Usage Detected!"
  
  # Multiple separators
  log_separator
  
  # Long form structured logging
  log_structured info \
    "component=webserver" \
    "status=healthy" \
    "connections=1247" \
    "response_time=23ms" \
    "memory_usage=67%" \
    "cpu_usage=23%" \
    "disk_usage=45%" \
    "uptime=7d_14h_32m"
  
  log_separator
  
  # Error handling demo
  log_step "‚ùå 10. Error Handling & Edge Cases"
  log_error "üö® Simulated critical error (this goes to stderr)"
  log_warn "‚ö†Ô∏è Warning: Low disk space on /var partition"
  log_success "‚úÖ Error recovery completed successfully"
  
  log_separator
  
  # Performance demo
  log_step "üöÄ 11. Performance Benchmark"
  log_benchmark
  
  log_separator
  
  local demo_duration=$(($(date +%s) - demo_start_time))
  log_success "üéâ Demo completed successfully! (${demo_duration}s total)"
  
  # Show final configuration
  log_config_show
}

# Install missing dependencies
install_dependencies() {
  log_banner "Dependency Installation" "Installing required packages"
  
  log_step "Checking system requirements..."
  local os_id
  os_id=$(detect_os)
  local pm
  pm=$(get_package_manager)
  
  log_structured info "os=$os_id" "package_manager=$pm"
  
  log_step "Checking sudo/root permissions..."
  if ! check_sudo_requirement; then
    log_error "Installation failed due to insufficient permissions"
    return 1
  fi
  
  log_step "Checking and installing Gum..."
  ensure_gum_installed
  
  log_step "Checking and installing getoptions..."
  ensure_getoptions_installed
  
  log_separator
  
  # Show final status
  log_step "Installation Summary:"
  local gum_status="‚ùå Not available"
  local getoptions_status="‚ùå Not available"
  
  if [[ "$_log_has_gum" == "true" ]]; then
    local gum_version
    gum_version=$(gum --version 2>/dev/null | grep -o 'v[0-9.]*[0-9]' | head -1 || echo "unknown")
    gum_status="‚úÖ Installed ($gum_version)"
  fi
  
  if [[ "$_log_has_getoptions" == "true" ]]; then
    local getoptions_version
    getoptions_version=$(getoptions --version 2>/dev/null | grep -o 'v[0-9.]*' | head -1 || echo "unknown")
    getoptions_status="‚úÖ Installed ($getoptions_version)"
  fi
  
  log_structured info "gum=$gum_status" "getoptions=$getoptions_status"
  
  log_success "Dependency installation completed!"
  
  # Reinitialize to update status
  _log_initialized=false
  _log_init
}

#################################################################
# MAIN FUNCTION
#################################################################

main() {
  # Initialize logging system
  log_init
  
  # Parse options based on available tools
  local remaining_args
  
  if [[ "$_log_has_getoptions" == "true" ]]; then
    # Temporarily disable getoptions due to compatibility issues
    # TODO: Fix getoptions integration in future version
    _log_has_getoptions=false
  fi
  
  if [[ "$_log_has_getoptions" != "true" ]]; then
    # Use simple fallback parsing
    while [[ $# -gt 0 ]]; do
      case "$1" in
        --level)
          LOG_LEVEL="${2^^}"
          shift 2
          ;;
        --level=*)
          LOG_LEVEL="${1#*=}"
          LOG_LEVEL="${LOG_LEVEL^^}"
          shift
          ;;
        -l)
          LOG_LEVEL="${2^^}"
          shift 2
          ;;
        --file)
          LOG_FILE="$2"
          shift 2
          ;;
        --file=*)
          LOG_FILE="${1#*=}"
          shift
          ;;
        -f)
          LOG_FILE="$2"
          shift 2
          ;;
        --module)
          LOG_MODULE="$2"
          shift 2
          ;;
        --module=*)
          LOG_MODULE="${1#*=}"
          shift
          ;;
        -m)
          LOG_MODULE="$2"
          shift 2
          ;;
        --debug|-d)
          LOG_DEBUG="true"
          shift
          ;;
        --quiet|-q)
          LOG_QUIET="true"
          shift
          ;;
        --no-colors)
          LOG_ENABLE_COLORS="false"
          shift
          ;;
        --help|-h)
          show_help_fallback
          exit 0
          ;;
        --version|-V)
          log_version
          exit 0
          ;;
        -*)
          echo "Warning: Unknown option $1, ignoring" >&2
          shift
          ;;
        *)
          break
          ;;
      esac
    done
  fi
  
  # Update cached values after option parsing
  _update_cached_values
  
  # Handle empty command
  if [[ $# -eq 0 ]]; then
    if [[ "$_log_has_getoptions" == "true" ]]; then
      usage
    else
      show_help_fallback
    fi
    exit 0
  fi
  
  local command="$1"
  shift
  
  case "$command" in
    # Log commands
    info|warn|error|success|step|debug)
      handle_log_command "$command" "$@"
      ;;
    
    # Structured logging
    structured)
      if [[ $# -lt 2 ]]; then
        log_error "Usage: $SCRIPT_NAME structured <level> <key=value> [key=value]..."
        exit 1
      fi
      handle_structured_command "$@"
      ;;
    
    template)
      if [[ $# -lt 2 ]]; then
        log_error "Usage: $SCRIPT_NAME template <level> <template> [key=value]..."
        exit 1
      fi
      handle_template_command "$@"
      ;;
    
    # Visual elements
    banner)
      if [[ $# -lt 1 ]]; then
        log_error "Usage: $SCRIPT_NAME banner <title> [subtitle]"
        exit 1
      fi
      handle_banner_command "$@"
      ;;
    
    separator)
      log_separator
      ;;
    
    progress)
      if [[ $# -lt 2 ]]; then
        log_error "Usage: $SCRIPT_NAME progress <title> <command>"
        exit 1
      fi
      handle_progress_command "$@"
      ;;
    
    # Configuration
    config)
      handle_config_command "$@"
      ;;
    
    show-config)
      log_config_show
      ;;
    
    reset-config)
      log_config_reset
      ;;
    
    # Utility commands
    benchmark)
      log_benchmark
      ;;
    
    test)
      run_comprehensive_tests
      ;;
    
    demo)
      run_feature_demo
      ;;
    
    install-deps)
      install_dependencies
      ;;
    
    version)
      log_version
      ;;
    
    help)
      if [[ "$_log_has_getoptions" == "true" ]]; then
        usage
      else
        show_help_fallback
      fi
      ;;
    
    *)
      log_error "Unknown command: $command"
      echo "Use '$SCRIPT_NAME --help' for usage information."
      exit 1
      ;;
  esac
}

# Auto-initialization on source
_log_init

# Run main function with all arguments if script is executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  main "$@"
fi
